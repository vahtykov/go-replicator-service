---
alwaysApply: true
---

## План работ по реализации прикладной репликации:

1) ReplicatorPublisher - реализация сервиса на Golang.
1.1) Чтение таблицы replication_queue раз в N секунд (по-умолчанию раз в секунду), выборка записей с флагом published = false (если PG_SSL=Y подключаемся по SSL)
1.2) Публикация операций в Kafka (если ENV KAFKA_SSL=Y - подключаемся по SSL)
1.3) Пометка успешно обработанных записей как published = true (продумать, как избежать deadlocks в кейсах, когда в replication_queue одновременно будет писать триггер и читать ReplicatorPublisher - предложи решение и согласуй со мной)
1.4) Гарантия at least once delivery


2) ReplicatorConsumer - реализация сервиса на Golang.
2.1) Чтение реплицируемых данных из Kafka (своя consumer group на каждом контуре)
2.2) Фильтрация сообщений, применение только DML с противоположного контура (предотвращение петли репликации сейчас реализовано на уровне триггера, продумать, возможно добавить доп защиту прикладного уровня)
2.3) Проверка идемпотентности записи перед применением, по таблице replication_processed_events
2.4) Проверка версии записи перед применением на БД (по колонке version)
2.5) Применение DML на таблицы БД

## Conventions
- для реализации cron используй библиотеку go-co-op/gocron
- для логирования используй zerolog
- для работы с бд используй GORM
- выключи prepared statements при подключении к postgres
- настрой вывод логов запросов postgres, и отключи цветной вывод логов
- для работы с kafka используй confluent-kafka-go